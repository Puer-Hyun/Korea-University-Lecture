* A->C로 가는 경로와 A->B, B->C를 이용해서 최단거리를 결정한다는 점에서 DP의 일부라고 볼 수도 있지만, 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 것을 선택하는 맥락에서 그리디 알고리즘으로 분류가 되기도 한다.

1. 출발노드를 설정한다.
2. 최단 거리 테이블을 초기화한다.
   1. 초기화 과정에서 처음에는 기본적으로 모든 노드까지의 비용을 무한으로 설정한다. 그리고 자기 자신에 대한 과정은 0으로 설정한다. 
3. <span style="color:red">방문하지 않은 노드</span> 중에서 최단 거리가 가장 짧은 노드를 선택한다.
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
5. 위의 과정에서 3번과 4번을 반복한다.


## 특징 
* 총 $O(V)$번에 걸쳐서 최단거리가 가장 짧은 노드를 매번 선형 탐색해야한다.
* 따라서 전체 시간 복잡도는 $O(V^2)$이다.
* 일반적으로 코테의 최단경로문제에서 전체 노드의 개수가 5000개 이하라면 이 코드로 문제를 해결할 수 있다. 그러나 10000개가 넘어가면?
```python

import sys
input = sys.stdin.readline 
INF = int(1e9)

n, m = map(int, input().split())
start = int(input())
graph = [[] for i in range(n+1)]
visited = [False] * (n+1)
distance = [INF] * (n+1)

for _ in range(m):
    a,b,c = map(int, input().split())
    graph[a].append((b,c))

def get_smallest_node():
    min_value = INF
    index = 0
    for i in range(1, n+1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    return index

def dijkstra(start):
    distance[start]=0
    visited[start]=0
    for j in graph[start]:
        distance[j[0]]=j[1] 
    for i in range(n-1):
        now = get_smallest_node()
        visited[now]=True
        for j in graph[now]:
            cost = distance[now] + j[1]
            if cost < distance[j[0]]:
                distance[j[0]] = cost
dijkstra(start)
for i in range(1, n+1):
    if distance[i] == INF:
        print("INF")
    else:
        print(distance[i])

```

## 개선된 다익스트라
* Heapq을 활용한다.
* ![](images/2023-06-18-19-08-39.png)